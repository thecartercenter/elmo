<%# render the answer value based on question type. we include machine readable value in
    data-val so that conditions can still be eval'd in JS %>
<% case type = answer_set.qtype.name
   when 'select_one' %>

  <div class="ro-val" data-val="<%=json answer_set.option_ids_with_no_nils %>">
    <%= render('option_sets/cascading_selects', index: index, option_path: answer_set.option_path) %>
  </div>

<% when 'select_multiple' %>

  <%= content_tag(:div, answer_set.choices.map{|c| c.option.name}.join('<br/>').html_safe, :class => 'ro-val', :'data-val' => answer_set.choices.map(&:option_id).to_json) %>

<% when 'datetime', 'date', 'time' %>

  <% format = type == "time" ? :time_only : :default %>
  <% val = answer_set.send("#{type}_value") %>

  <%# output time value in human readable and machine readable formats %>
  <%= content_tag(:div, val.nil? ? '' : l(val, :format => format), :class => 'ro-val', :'data-val' => val.nil? ? '' : val.to_s(:"std_#{type}")) %>

<% when 'integer', 'decimal' %>

  <%= content_tag(:div, answer_set.value, :class => 'ro-val', :'data-val' => answer_set.value) %>

<% when 'text', 'long_text' %>

  <%# show search excerpt (highlights search terms) if exists for this questioning, else just show plain answer value %>
  <%# no need to output data-val here since same as human readable %>
  <%= content_tag(:div, excerpt_if_exists(@response, answer_set.first)) %>

<% else %>

  <%# no need to output data-val here since same as human readable %>
  <%= content_tag(:div, answer_set.value) %>

<% end # case %>
